rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if a user is one of the admin types
    function isAdmin() {
      let userDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      // Ensure the user document exists and has a role that's in the admin list
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             'role' in userDoc.data &&
             userDoc.data.role in ['admin', 'CRO', 'Super-admin'];
    }

    // Helper function to check if user is a Principal
    function isPrincipal() {
      let userProfileDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             'designation' in userProfileDoc.data &&
             userProfileDoc.data.designation == 'Principal';
    }

    // Helper function to check if user is an HOD
    function isHod() {
      let userProfileDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             'designation' in userProfileDoc.data &&
             userProfileDoc.data.designation == 'HOD';
    }

    // Helper function to check if user is a Principal for the given project
    function isPrincipalForProject(projectData) {
      let userProfileDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isPrincipal() &&
             'institute' in userProfileDoc.data &&
             projectData.keys().hasAny(['institute']) &&
             userProfileDoc.data.institute == projectData.institute;
    }
    
    // Helper function to check if user is an HOD for the given project
    function isHodForProject(projectData) {
      let userProfileDoc = get(/databases/$(database)/documents/users/$(request.auth.uid));
      return isHod() &&
             'department' in userProfileDoc.data &&
             projectData.keys().hasAny(['departmentName']) &&
             userProfileDoc.data.department == projectData.departmentName;
    }
    
    // Helper function to check if the requesting user is an assigned evaluator for THIS project.
    function isAssignedEvaluator(projectData) {
      return 'meetingDetails' in projectData &&
             projectData.meetingDetails != null &&
             'assignedEvaluators' in projectData.meetingDetails &&
             projectData.meetingDetails.assignedEvaluators != null &&
             request.auth.uid in projectData.meetingDetails.assignedEvaluators;
    }

    // This is a "god-mode" rule. If a user is an admin, they can do anything.
    // This rule is checked first. If it's true, access is granted.
    match /{path=**} {
      allow read, write: if isAdmin();
    }
    
    // The following rules apply to non-admin users.
    
    match /users/{userId} {
      // Any signed-in user can read a public profile.
      allow read: if request.auth != null;
      // A user can create their own document.
      allow create: if request.auth.uid == userId;
      // A user can only update their own document. Admins are covered by the global rule above.
      allow update: if request.auth.uid == userId;
      allow delete: if request.auth.uid == userId;
    }
    
    match /projects/{projectId} {
      // A user can get a specific project document if they are the PI, an assigned evaluator, a Principal, or an HOD.
      // This rule is what allows the document to be read on the project details page.
      allow get: if request.auth.uid == resource.data.pi_uid ||
                   request.auth.uid in resource.data.coPiUids ||
                   isAssignedEvaluator(resource.data) ||
                   isPrincipalForProject(resource.data) ||
                   isHodForProject(resource.data);
      
      // List access is more complex. You can't just filter on the client.
      // Rules must allow the query to run on the server.
      // Any authenticated user can query for their own projects (as PI or Co-PI) or evaluation assignments.
      // Principals and HODs can query for projects in their institute/department.
      allow list: if request.auth != null && (
                    (request.query.keys().hasAll(['where', 'orderBy']) && request.query.where[0][0] == 'pi_uid') ||
                    (request.query.keys().hasAll(['where', 'orderBy']) && request.query.where[0][0] == 'coPiUids') ||
                    (request.query.keys().hasAll(['where', 'orderBy']) && request.query.where[0][0] == 'meetingDetails.assignedEvaluators') ||
                    (isPrincipal() && request.query.keys().hasAll(['where', 'orderBy']) && request.query.where[0][0] == 'institute') ||
                    (isHod() && request.query.keys().hasAll(['where', 'orderBy']) && request.query.where[0][0] == 'departmentName')
                   );

      // A user can only create a project where they are the PI.
      // They cannot set the status to anything other than Draft/Submitted.
      allow create: if request.auth.uid == request.resource.data.pi_uid &&
                      request.resource.data.status in ['Draft', 'Submitted'] &&
                      !('grant' in request.resource.data) &&
                      !('meetingDetails' in request.resource.data);
      
      // A PI can update their own project (e.g., submit completion report), but cannot change status or grant details.
      // An assigned evaluator can update the project ONLY to add their UID to the evaluatedBy array.
      allow update: if (request.auth.uid == resource.data.pi_uid && !('status' in request.resource.data.diff(resource.data).affectedKeys()) && !('grant' in request.resource.data.diff(resource.data).affectedKeys())) ||
                      (isAssignedEvaluator(resource.data) && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['evaluatedBy']));

      // Rules for the evaluations subcollection inside a project
      match /evaluations/{evaluatorId} {
        // We use the parent document's `isAssignedEvaluator` logic here by calling get().
        // The 'get' rule on the project allows this call to succeed for assigned evaluators.
        function canAccessEvaluation() {
            let projectDoc = get(/databases/$(database)/documents/projects/$(projectId));
            return isAssignedEvaluator(projectDoc.data);
        }

        // Allow reading all evaluations for a project if you are an assigned evaluator for it.
        allow read: if canAccessEvaluation();
        
        // Allow writing an evaluation only if you are an assigned evaluator AND you are writing to your own document.
        allow write: if canAccessEvaluation() && request.auth.uid == evaluatorId;
      }
    }

    match /notifications/{notificationId} {
      // A user can read and update (e.g., mark as read) their own notifications.
      allow read, update: if request.auth.uid == resource.data.uid;
      // All notifications are created by the server using the Admin SDK, so client creation is denied.
      allow create: if false;
    }
    
    match /incentiveClaims/{claimId} {
      // A user can create and read their own incentive claims.
      allow create: if request.auth.uid == request.resource.data.uid;
      allow read: if request.auth.uid == resource.data.uid;
      // All status updates are handled by the server (Admin SDK), so client updates are denied.
      allow update: if false;
    }
  }
}
